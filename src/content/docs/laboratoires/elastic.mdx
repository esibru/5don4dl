---
title: Introduction à ElasticSearch

---
import { Card, Aside, Icon, Steps } from '@astrojs/starlight/components';

## 1) Introduction

Nous vous proposons ici une introduction à Elasticsearch, un système stockant des documents JSON (comme MongoDB donc) mais plutôt axé sur la recherche avancée, l'analyse et la visualisation des données.

La documentation officielle d'Elasticsearch mentionne de nombreuses entreprises qui en font usage pour les besoins cités ci-desssus, voyez:  https://www.elastic.co/customers


## 2) Installation d'ElasticSearch

Pour installer ElasticSearch via Docker:

``` bash showLineNumbers=false
docker run -d --name elasticsearch -p 9200:9200 -e "discovery.type=single-node" -e "xpack.security.enabled=false" docker.elastic.co/elasticsearch/elasticsearch:8.15.3
```

La commande devrait à présent vous semble familière, à l'exception sans doute des deux options 

`-e "discovery.type=single-node" -e "xpack.security.enabled=false"`.

La première option sert simplement à demander à ElastiSearch de fonctionner en mode 'standalone' (une seule instance d'ElasticSearch) plutôt qu'en mode 'cluster' (plusieurs instances d'ElasticSearch fonctionnant en parallèle).

Utiliser plusieurs instances d'ElasticSearch permet d'augmenter la scalabilité de l'installation (la capacité de stockage/de calcul), nous travaillerons en mode standalone pour moment (notre but est de découvrir ElasticSearch).

La deuxième option sert à désactiver la sécurité, ce qui sera pratique pour se connecter facilement à ElasticSearch dans un labo de découverte comme celui-ci.

<Aside type="caution" title="ElasticSearch en production">
Dans un environnement de production, ne désactivez évidemment pas la sécurité.
</Aside>

Consultez la documentation officielle d'ElasticSearch pour savoir comment configurer correctement la sécurité et les clusters éventuels, nous ne nous en préocupperons pas dans ce labo d'introduction.


ElasticSearch stocke les documents dans des `index`, l'équivalent d'une collection sous MongoDB.

<Aside type="caution" title="Index sous ElasticSearch">

Ne pas confondre la notion d'index sur un SGBD relationnel(=une structure de donnée permettant d'accéler les requêtes SQL) et un index sur ElasticSearch (=un conteneur pour les documents JSON).

</Aside>

ElasticSearch fournit essentiellement une API Rest (HTTP) pour communiquer.

Testez donc que le serveur est bien opérationnel au moyen de la commande:

``` bash showLineNumbers=false
curl http://localhost:9200
```

Le serveur répond normalement vous renvoyant quelques informations (le nom du cluster, notamment). 

Si vous le souhaitez, vous pouvez installer un outil de visualisation des données stockées appelé `Kibana`.

## 3) Utiliser ElasticSearch

Pour communiquer avec ElasticSearch nous pouvons au choix:

- lui envoyer directement une requête HTTP (GET, POST, ...).

- utiliser l'interface graphique Kibana (à installer séparément, voir la documention officielle).

- utiliser une librairire cliente lié à un langage et accéder au serveur au moyen de cette librairie.


Essayons donc d'enregistrer un premier document en envoyant une requête `POST` au serveur:

``` bash showLineNumbers=false
curl -X POST "http://localhost:9200/cours/_doc/1" \
  -H 'Content-Type: application/json' \
  -d '{"UE": "5DON4", "annee": 2025, "nbEcts": 4}'
```













Comme expliqué en 2DON1, les bases de données orientées document permettent de stocker les données sous la forme d'un document d'un format donné. Ce format est généralement soit du JSON soit de l'XML.

Nous vous proposons ici une introduction à MongoDB, un SGBD orienté document axé sur le JSON.

![image](images/mongoJsonExample.png)

Le JSON est naturellement présent dans le code JavaScript des applications web, ce qui facilite (dans beaucoup de cas) l'implémentation de la persistance des données d'une telle application: il n'est plus nécessaire d'écrire du code pour faire correspondre les données JSON et la structure d'une base de données relationnelle normalisée.

Ceci est un cas particulier du problème plus général, évoqué en 2DON1 et présent en informatique depuis (au moins) les années 1990: la différence de paradigmes entre modèle relationnel (d'une part) et programmation orientée objet (d'autre part). Comment faire correspondre le plus rapidement possible les données des objets de notre application avec celles de la base de données ?

Dans le cas où les données de l'application sont encodées en JSON, un système comme MongoDB apporte une solution à ce problème.

## 2) MongoDB

La documentation officielle de MongoDb est disponible ici: https://www.mongodb.com/ 

**Attention**: MongoDB est disponible en plusieurs versions, dont une version cloud nommée 'Atlas'. Cette dernière est fort mise en avant dans la documentation, nous ne nous en préoccuperons pas et utiliserons simplement la version 'Community' (gratuite).

Nous vous proposons à nouveau une installation via Docker. La commande à utiliser est similaire à celles utilisés pour Redis/Neo4j (nous utilisons cette fois le port 27017, standard pour la communication avec le serveur MongoDB):

``` bash showLineNumbers=false
docker run --name MyMongoDB -d -p 27017:27017 mongo
```

Comme auparavant, ayez à l'esprit les commandes de base de docker pour gérer le conteneur (`docker ps`, `docker logs`, `docker start`, `docker stop`).

Connectez-vous à **mongosh**, la ligne de commande (shell) du serveur MongoDB:

``` bash showLineNumbers=false
docker exec -it MyMongoDB mongosh
```

### Gestion des bases de données sous MongoDB

MongoDB vous permet de créer plusieurs bases de données distinctes. Pour voir les bases de données disponibles, tapez:

``` bash showLineNumbers=false
show dbs
```

Vous voyez apparaître plusieurs bases de données crées automatiquement par MongoDB lors de l'installation (`admin`, `config`, `local`), nous n'y toucherons pas pour le moment.

La commande `use` permet de se connecter à une base de données existante. Si le nom fournit ne correspond pas à une base de donnée existante, elle est créée. Créez votre base de données en tapant:

``` bash showLineNumbers=false
use MyDB
```

Pour voir la base de données à laquelle vous êtes connecté, tapez simplement:

``` bash showLineNumbers=false
db
```

## 3) Documents et collections

MongoDB permet donc de stocker des **documents**, c'est-à-dire des données au format JSON (En réalité, MongoDB ne stocke pas immédiatement les données en JSON mais plutôt dans un format proche appelé le **BSON**, nous en parlerons plus loin).

Ces documents sont rassemblés au sein d'une **collection** (et chaque collection appartient à une base de données, créées comme expliqué à la section précédente).

Par rapport à une base de donnée relationnelle standard, la documentation officielle MongoDB suggère l'analogie suivante:

- une collection (MongoDB) = une table (SGBD relationnel),
- un document JSON (MongoDB) = une ligne de données (SGBD relationnel).

Attention, cependant:

<Aside type="caution" title="Une collection n'impose pas de contraintes !">

Par défaut, MongoDB n'impose aucune contrainte sur les documents d'un schéma. Les documents JSON insérés dans la collection ne doivent pas nécessairement posséder les mêmes clés. Nous verront plus loin comment demander à MongoDB de spécifier un schéma pour les données d'une collection.

</Aside>

### Créer une collection ou un document

MongoDB crée automatiquement une nouvelle collection lorsqu'on stocke une donnée dedans pour la première fois. Pour stocker une telle donnée, utilisez la commande:

``` bash showLineNumbers=false
db.myNewCollection1.insertOne({<données JSON>})
```

Si on le souhaite, on peut aussi créer `myNewCollection1` explicitement (avant d'y insérer des documents):

``` bash showLineNumbers=false
db.createCollection("myNewCollection1")
```

Nous verrons (ci-dessous) que la méthode `createCollection` est utile lorsqu'on shoutaite configurer la collection.

Par exemple:

``` bash showLineNumbers=false
db.clients.insertOne({name: "Louis", age: 34})
```

insère un nouveau client de nom Louis et d'âge 34 dans la collections `clients` (celle-ci est créée si elle n'existe pas déjà). Pour lister les clients existants:

``` bash showLineNumbers=false
db.clients.find()
```

Remarquez que MongoDB assigne automatiquement un identifiant à chaque nouveau document (l'identifiant appartient possède un type de donnée particulier discuté ci-dessous).

<Card title="MongoDB" icon="pencil"> 
Lancer mongosh et créez une nouvelle base de données (si ce n'est déjà fait). Ajoutez quelques clients dans la collection `clients`. Ajoutez plusieurs clients ayant 30 ans.

Utilisez à présent la documentation officielle MongoDB pour:

- afficher tous les clients ayant 30 ans (a vous de voir quelle commande utiliser).

- supprimer tous les clients ayant 30 ans, et uniquement ceux là (a vous de voir quelle commande utiliser).

</Card>


## 4) BSON, JSON et la validation de schéma

Sous MongoDB, les documents sont stockés en interne dans un format binaire spécifique appelé le **BSON** (acronyme de Binary jSON), que l'on peut voir comme une représentation binaire du JSON.

Les avantages à utiliser un tel format sont, notamment, de:

- proposer une plue grande variété de types de données, par exemple des dates (non supporté par le JSON standard, les dates sont encodées comme des string en JSON),

- ajouter des métadonnées lors du stockage, comme la taille du document ou le type de données des valeurs. Ceci permet à MongoDB de parser les documents JSON plus rapidement.

Pour utiliser des dates, par exemple, il suffit d'écrire:

``` bash showLineNumbers=false
db.clients.insertOne({ name: "Charlot", bdate : new Date("2000-01-03") }) 
```

Lorsqu'on affiche les données de ce client, MongoDB répond:

``` bash showLineNumbers=false
{
    _id: ObjectId('6899b47648f97bd1ac89b045'),
    name: 'Charlot',
    bdate: ISODate('2000-01-03T00:00:00.000Z')
}
```

ce qui signifie que MongoDB a créé un nouveau champ de type `ISODate` pour la clé `bdate`. Remarquez aussi que les identifiants générés automatiquement par MongoDB sont de type `ObjectId`.

Consultez la documentation officielle de MongoDB pour avoir un aperçu détaillé des types de données proposés.

Nous sommes en présent en mesure d'imposer un schéma pour une collection données. Nous voudrions par exemple imposer que chaque document de la collection `clients` possède:

- une clé `nom`, de type string,
- une clé `bdate`, de type date.

Pour cela, nous allons créer la collection clients en utilisant le canevas suivant:

``` bash showLineNumbers=false
db.createCollection("clients", spécifications-des-contraintes)
```

<Card title="Spécifier un schéma sous MongoDB" icon="pencil"> 
Utilisez la documentation officielle de MongoDB (constultez simplement la page appelée "Specify JSON Schema Validation") pour définir le schéma précisé ci-dessus pour la collection `clients`.
Vérifiez que MongoDB n'accepte l'insertion d'un nouveau client dans cette collection que si les clés nom et bdate sont présentes (avec le bon type de donnée).
</Card>

## 5) Client Java

Se connecter à MongoDB via un code Java est à nouveau très simple. Ajoutez tout d'abord la dépendance suivante:
 
<Card title="Driver MongoDB" icon="seti:maven">
``` xml showLineNumbers=false
<dependency>
    <groupId>org.mongodb</groupId>
    <artifactId>mongodb-driver-sync</artifactId>
    <version>5.1.0</version>
</dependency>
```
</Card>

Après avoir importé les classes nécessaires ...

```java
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import org.bson.Document;
```

... la manipulation des données se fait très facilement:

```java
String connectionString = "mongodb://localhost:27017";

try (MongoClient mongoClient = MongoClients.create(connectionString)) {
     // Choix de la DB
     MongoDatabase database = mongoClient.getDatabase("test");
     // Choix de la collection (elle est créee si elle n'existe pas)
     MongoCollection<Document> collection = database.getCollection("employe");


     // Création d'un nouveau document
     Document monEmploye = new Document("name", "Charlot")
                    .append("age", 39)
                    .append("sexe", "M");

     // Insertion du document
     collection.insertOne(monEmploye);

} catch (Exception e) {
    System.err.println("Erreur de connexion : " + e.getMessage());
}
```

Remarquez comme l'ajout de couples clé/valeur est simple et élégant. Attention cependant: si la collection utilisée pour l'insertion spécifie un schéma, les données insérées doivent satisfaire toutes les contraintes du schéma. Ceci peut en particulier donner lieu à des conversions entre les types de données MongoDB et les types de données Java. Dans l'exemple ci-dessus, nous nous sommes volontairement limités à des String/des entiers.

<Card title="Application gérant des utilisateurs" icon="pencil"> 
Ecrire une application Java demandant des données d'employe (nom, âge et sexe) à l'utilisateur et qui insère  ces données dans la collection employe du serveur MongoDB local.
</Card>
